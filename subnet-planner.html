
                        <!DOCTYPE html>
                        <html lang="en">
                        <head>
                            <meta charset="UTF-8">
                            <meta name="viewport" content="width=device-width, initial-scale=1.0">
							<style>
								body {
									background-color: white; /* Ensure the iframe has a white background */
								}

								:root{
  --bg:#0b1020;
  --panel:#121a33;
  --text:#e8ecff;
  --muted:#aab4e6;
  --border:rgba(232,236,255,.12);
  --accent:#7aa2ff;
  --accent2:#52e3c2;
  --danger:#ff6b6b;
  --shadow: 0 10px 30px rgba(0,0,0,.35);
  --radius: 14px;
  --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
}

*{ box-sizing:border-box; }
body{
  margin:0;
  font-family:var(--sans);
  background: radial-gradient(1200px 600px at 20% 0%, rgba(122,162,255,.25), transparent 55%),
              radial-gradient(900px 500px at 90% 10%, rgba(82,227,194,.18), transparent 50%),
              var(--bg);
  color:var(--text);
}

.app{
  max-width: 1100px;
  margin: 0 auto;
  padding: 22px;
}

.header{
  display:flex;
  align-items:flex-end;
  justify-content:space-between;
  gap: 16px;
  margin-bottom: 14px;
}
h1{ margin:0; font-size: 28px; letter-spacing:.2px; }
h2{ margin:0 0 6px 0; font-size: 16px; }
.subtitle{ margin:6px 0 0 0; color:var(--muted); font-size: 13px; line-height: 1.4; }

.panel{
  background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
  border: 1px solid var(--border);
  border-radius: var(--radius);
  box-shadow: var(--shadow);
  padding: 14px;
  margin: 12px 0;
}

.row{
  display:flex;
  gap: 12px;
  flex-wrap: wrap;
  align-items: flex-end;
}

.field{
  display:flex;
  flex-direction: column;
  gap: 6px;
}
.field span{
  font-size: 12px;
  color: var(--muted);
}
input[type="text"]{
  width: 250px;
  padding: 10px 12px;
  border-radius: 10px;
  border: 1px solid var(--border);
  background: rgba(0,0,0,.25);
  color: var(--text);
  outline: none;
}
input[type="text"]:focus{
  border-color: rgba(122,162,255,.7);
  box-shadow: 0 0 0 3px rgba(122,162,255,.15);
}

.toggle{
  display:flex;
  align-items:center;
  gap: 8px;
  user-select:none;
  color: var(--muted);
  font-size: 13px;
}
.toggle input{ transform: translateY(1px); }

.btn{
  padding: 10px 12px;
  border-radius: 10px;
  border: 1px solid var(--border);
  background: rgba(255,255,255,.04);
  color: var(--text);
  cursor:pointer;
}
.btn:hover{ border-color: rgba(232,236,255,.24); }
.btn.primary{
  background: rgba(122,162,255,.15);
  border-color: rgba(122,162,255,.45);
}
.btn.danger{
  background: rgba(255,107,107,.12);
  border-color: rgba(255,107,107,.35);
}
.btn:disabled{
  opacity: .55;
  cursor: not-allowed;
}

.spacer{ flex: 1 1 auto; }

.error{
  margin-top: 10px;
  padding: 10px 12px;
  border-radius: 10px;
  border: 1px solid rgba(255,107,107,.35);
  background: rgba(255,107,107,.10);
  color: #ffd5d5;
  font-size: 13px;
}

.tableWrap{ overflow:auto; }
.table{
  width:100%;
  border-collapse: collapse;
  min-width: 820px;
}
.table th, .table td{
  padding: 10px 10px;
  border-bottom: 1px solid var(--border);
  vertical-align: middle;
}
.table th{
  text-align:left;
  color: var(--muted);
  font-weight: 600;
  font-size: 12px;
  letter-spacing: .3px;
}
.table td{
  font-size: 13px;
}
.table tr:hover td{
  background: rgba(255,255,255,.02);
}

.nameInput{
  width: 100%;
  min-width: 160px;
  padding: 8px 10px;
  border-radius: 10px;
  border: 1px solid var(--border);
  background: rgba(0,0,0,.22);
  color: var(--text);
  outline:none;
}
.nameInput:focus{
  border-color: rgba(82,227,194,.55);
  box-shadow: 0 0 0 3px rgba(82,227,194,.12);
}

.badge{
  font-family: var(--mono);
  font-size: 12px;
  padding: 3px 8px;
  border-radius: 999px;
  border: 1px solid var(--border);
  background: rgba(0,0,0,.22);
  color: var(--text);
  display:inline-block;
}

.code{
  margin: 0;
  padding: 12px;
  border-radius: 12px;
  border: 1px solid var(--border);
  background: rgba(0,0,0,.30);
  overflow:auto;
}
.code code{
  font-family: var(--mono);
  font-size: 12px;
  color: #dce3ff;
}

.outputHeader{
  display:flex;
  align-items: baseline;
  justify-content: space-between;
  gap: 16px;
}

.footer{
  margin-top: 10px;
  color: var(--muted);
  text-align:center;
}
							</style>
                        </head>
                        <body>
                            <!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Subnet Planner</title>
  <link rel="stylesheet" href="./assets/styles/main.css" />
</head>
<body>
  <div class="app">
    <header class="header">
      <div>
        <h1>Subnet Planner</h1>
        <p class="subtitle">IPv4 subnet planning with divide/join, naming, and copy-paste JSON/HTML output.</p>
      </div>
    </header>

    <section class="panel">
      <div class="row">
        <label class="field">
          <span>Base CIDR</span>
          <input id="baseCidr" type="text" placeholder="e.g., 10.0.0.0/16" spellcheck="false" />
        </label>

        <button id="applyBase" class="btn primary">Apply</button>
        <button id="reset" class="btn">Reset</button>

        <div class="spacer"></div>

        <label class="toggle">
          <input id="showDetails" type="checkbox" />
          <span>Show details</span>
        </label>

        <label class="toggle">
          <input id="outputFormat" type="checkbox" />
          <span id="outputFormatLabel">Output: JSON</span>
        </label>

        <button id="copyOutput" class="btn">Copy</button>
      </div>

      <div id="error" class="error" hidden></div>
    </section>

    <section class="panel">
      <div class="tableWrap">
        <table class="table" id="subnetTable" aria-label="Subnet table">
          <!-- rendered -->
        </table>
      </div>
    </section>

    <section class="panel">
      <div class="outputHeader">
        <h2>Copy/Paste Output</h2>
        <p class="subtitle" id="outputHint">JSON reflects leaf subnets only (current plan).</p>
      </div>
      <pre class="code"><code id="outputCode"></code></pre>
    </section>

    <footer class="footer">
      <small>Local-only app. No data leaves your browser.</small>
    </footer>
  </div>

  <script type="module" src="./src/main.js"></script>
</body>
</html>

							<script>
                            	// IPv4 helpers: parse CIDR, compute fields, split blocks
// Modern behavior: /31 usable=2 (RFC 3021), /32 usable=1

export function parseCidr(cidr) {
  const m = String(cidr).trim().match(/^(\d{1,3}(?:\.\d{1,3}){3})\s*\/\s*(\d{1,2})$/);
  if (!m) throw new Error("Invalid CIDR format. Example: 10.0.0.0/16");

  const ip = m[1];
  const prefix = Number(m[2]);
  if (!Number.isInteger(prefix) || prefix < 0 || prefix > 32) {
    throw new Error("Prefix must be between 0 and 32.");
  }

  const ipInt = ipToInt(ip);
  const maskInt = prefixToMaskInt(prefix);
  const netInt = (ipInt & maskInt) >>> 0;

  return { cidr: `${intToIp(netInt)}/${prefix}`, ipInt: netInt, prefix };
}

export function ipToInt(ip) {
  const parts = ip.split(".").map(x => Number(x));
  if (parts.length !== 4 || parts.some(n => !Number.isInteger(n) || n < 0 || n > 255)) {
    throw new Error(`Invalid IPv4 address: ${ip}`);
  }
  // >>>0 to keep unsigned
  return (((parts[0] << 24) >>> 0) | (parts[1] << 16) | (parts[2] << 8) | parts[3]) >>> 0;
}

export function intToIp(n) {
  return [
    (n >>> 24) & 255,
    (n >>> 16) & 255,
    (n >>> 8) & 255,
    n & 255
  ].join(".");
}

export function prefixToMaskInt(prefix) {
  if (prefix === 0) return 0 >>> 0;
  return (0xFFFFFFFF << (32 - prefix)) >>> 0;
}

export function maskIntToDotted(maskInt) {
  return intToIp(maskInt >>> 0);
}

export function blockSize(prefix) {
  return 2 ** (32 - prefix);
}

export function broadcastInt(netInt, prefix) {
  const size = blockSize(prefix);
  return (netInt + size - 1) >>> 0;
}

export function usableCount(prefix) {
  if (prefix === 32) return 1;
  if (prefix === 31) return 2;
  const total = blockSize(prefix);
  return Math.max(0, total - 2);
}

export function firstUsableInt(netInt, prefix) {
  if (prefix === 32) return netInt >>> 0;
  if (prefix === 31) return netInt >>> 0; // both usable
  return (netInt + 1) >>> 0;
}

export function lastUsableInt(netInt, prefix) {
  if (prefix === 32) return netInt >>> 0;
  if (prefix === 31) return (netInt + 1) >>> 0;
  return (broadcastInt(netInt, prefix) - 1) >>> 0;
}

export function describeCidr(cidr) {
  const { ipInt: netInt, prefix } = parseCidr(cidr);
  const maskInt = prefixToMaskInt(prefix);
  const total = blockSize(prefix);
  const usable = usableCount(prefix);

  return {
    cidr: `${intToIp(netInt)}/${prefix}`,
    network: intToIp(netInt),
    prefix,
    mask: maskIntToDotted(maskInt),
    total,
    usable,
    broadcast: intToIp(broadcastInt(netInt, prefix)),
    firstUsable: intToIp(firstUsableInt(netInt, prefix)),
    lastUsable: intToIp(lastUsableInt(netInt, prefix))
  };
}

export function splitCidr(cidr) {
  const { ipInt: netInt, prefix } = parseCidr(cidr);
  if (prefix >= 32) throw new Error("Cannot divide a /32.");
  const childPrefix = prefix + 1;
  const size = blockSize(childPrefix);

  const leftNet = netInt >>> 0;
  const rightNet = (netInt + size) >>> 0;

  return [`${intToIp(leftNet)}/${childPrefix}`, `${intToIp(rightNet)}/${childPrefix}`];
}

import { parseCidr, splitCidr } from "../net/subnet.js";

function uid() {
  return Math.random().toString(16).slice(2) + "-" + Date.now().toString(16);
}

export function createStore() {
  const state = {
    baseCidr: "10.0.0.0/24",
    showDetails: false,
    outputMode: "json", // "json" | "html"
    rootId: null,
    nodes: {}, // id -> {id, cidr, name, parentId, children:[id,id] | null }
  };

  function initWithBase(cidr) {
    const parsed = parseCidr(cidr); // normalizes to network address
    state.baseCidr = parsed.cidr;
    state.nodes = {};
    const rootId = uid();
    state.rootId = rootId;
    state.nodes[rootId] = { id: rootId, cidr: parsed.cidr, name: "", parentId: null, children: null };
  }

  function getNode(id) {
    const n = state.nodes[id];
    if (!n) throw new Error(`Unknown node id: ${id}`);
    return n;
  }

  function leafIds() {
    const out = [];
    const walk = (id) => {
      const n = getNode(id);
      if (!n.children) out.push(id);
      else {
        walk(n.children[0]);
        walk(n.children[1]);
      }
    };
    walk(state.rootId);
    // sort by numeric network then prefix (stable)
    out.sort((a, b) => {
      const na = parseCidr(getNode(a).cidr);
      const nb = parseCidr(getNode(b).cidr);
      if (na.ipInt !== nb.ipInt) return na.ipInt - nb.ipInt;
      return na.prefix - nb.prefix;
    });
    return out;
  }

  function canJoin(id) {
    const n = getNode(id);
    if (!n.parentId) return false;
    const p = getNode(n.parentId);
    return Array.isArray(p.children) && p.children.length === 2;
  }

  function divide(id) {
    const n = getNode(id);
    if (n.children) return;
    const [a, b] = splitCidr(n.cidr);
    const leftId = uid();
    const rightId = uid();
    state.nodes[leftId] = { id: leftId, cidr: a, name: "", parentId: n.id, children: null };
    state.nodes[rightId] = { id: rightId, cidr: b, name: "", parentId: n.id, children: null };
    n.children = [leftId, rightId];
  }

  function join(id) {
    const n = getNode(id);
    if (!n.parentId) return;
    const p = getNode(n.parentId);
    if (!p.children) return;

    // remove both children
    const [c1, c2] = p.children;
    delete state.nodes[c1];
    delete state.nodes[c2];
    p.children = null;
  }

  function setName(id, name) {
    const n = getNode(id);
    n.name = String(name ?? "");
  }

  function setShowDetails(v) {
    state.showDetails = !!v;
  }

  function setOutputMode(mode) {
    state.outputMode = mode === "html" ? "html" : "json";
  }

  // init default
  initWithBase(state.baseCidr);

  return {
    state,
    initWithBase,
    leafIds,
    getNode,
    canJoin,
    divide,
    join,
    setName,
    setShowDetails,
    setOutputMode,
  };
}

import { describeCidr } from "../net/subnet.js";

export function toMinimalJson(leafNodes) {
  // Minimal: base fields only + name
  const rows = leafNodes.map(n => {
    const d = describeCidr(n.cidr);
    return {
      cidr: d.cidr,
      name: n.name || "",
      hosts: { total: d.total, usable: d.usable }
    };
  });
  return JSON.stringify(rows, null, 2);
}

import { describeCidr } from "../net/subnet.js";

function escapeHtml(s) {
  return String(s)
    .replaceAll("&", "&amp;")
    .replaceAll("<", "&lt;")
    .replaceAll(">", "&gt;")
    .replaceAll('"', "&quot;")
    .replaceAll("'", "&#039;");
}

export function toStaticHtmlTable(leafNodes, { showDetails }) {
  const headers = [
    "Subnet",
    "Name",
    "Hosts (total/usable)",
    ...(showDetails ? ["Mask", "Broadcast", "Range"] : []),
  ];

  const thead = `<thead><tr>${headers.map(h => `<th>${escapeHtml(h)}</th>`).join("")}</tr></thead>`;

  const tbodyRows = leafNodes.map(n => {
    const d = describeCidr(n.cidr);
    const hostCell = `${d.total} (${d.usable})`;
    const cells = [
      `<td><span class="badge">${escapeHtml(d.cidr)}</span></td>`,
      `<td>${escapeHtml(n.name || "")}</td>`,
      `<td>${escapeHtml(hostCell)}</td>`,
    ];

    if (showDetails) {
      cells.push(
        `<td>${escapeHtml(`${d.mask} (/${d.prefix})`)}</td>`,
        `<td>${escapeHtml(d.broadcast)}</td>`,
        `<td>${escapeHtml(`${d.firstUsable} - ${d.lastUsable}`)}</td>`
      );
    }

    return `<tr>${cells.join("")}</tr>`;
  }).join("");

  return `<table>\n${thead}\n<tbody>\n${tbodyRows}\n</tbody>\n</table>`;
}

import { describeCidr } from "../net/subnet.js";

export function renderApp(store, els) {
  const { state } = store;
  const leafIds = store.leafIds();
  const leafNodes = leafIds.map(id => store.getNode(id));

  // Table
  els.table.innerHTML = renderTableHtml(leafNodes, { showDetails: state.showDetails });

  // Wire events for table controls
  leafNodes.forEach(n => {
    const nameEl = els.table.querySelector(`[data-name="${n.id}"]`);
    nameEl.addEventListener("input", (e) => {
      store.setName(n.id, e.target.value);
      renderOutput(store, els);
    });

    const divideBtn = els.table.querySelector(`[data-divide="${n.id}"]`);
    divideBtn.addEventListener("click", () => {
      store.divide(n.id);
      renderApp(store, els);
    });

    const joinBtn = els.table.querySelector(`[data-join="${n.id}"]`);
    joinBtn.addEventListener("click", () => {
      store.join(n.id);
      renderApp(store, els);
    });
  });

  // Output
  renderOutput(store, els);
}

function renderTableHtml(leafNodes, { showDetails }) {
  const headCols = [
    `<th>Subnet</th>`,
    `<th>Subnet name</th>`,
    `<th>Hosts</th>`,
    ...(showDetails ? [`<th>Mask</th>`, `<th>Broadcast</th>`, `<th>Usable range</th>`] : []),
    `<th>Divide</th>`,
    `<th>Join</th>`,
  ].join("");

  const body = leafNodes.map(n => {
    const d = describeCidr(n.cidr);
    const hostsText = `${d.total} (${d.usable})`;

    const detailCells = showDetails
      ? `
        <td>${d.mask} <span class="muted">(/${d.prefix})</span></td>
        <td>${d.broadcast}</td>
        <td>${d.firstUsable} - ${d.lastUsable}</td>
      `
      : "";

    // Join enabled if node has parent and parent has two children (i.e., this leaf is joinable)
    const joinable = !!n.parentId;

    return `
      <tr>
        <td><span class="badge">${d.cidr}</span></td>
        <td>
          <input class="nameInput" data-name="${n.id}" type="text" value="${escapeAttr(n.name || "")}" placeholder="e.g., Users, DMZ..." />
        </td>
        <td>${hostsText}</td>
        ${detailCells}
        <td><button class="btn primary" data-divide="${n.id}" ${d.prefix === 32 ? "disabled" : ""}>Divide</button></td>
        <td><button class="btn" data-join="${n.id}" ${joinable ? "" : "disabled"}>Join</button></td>
      </tr>
    `;
  }).join("");

  return `
    <thead><tr>${headCols}</tr></thead>
    <tbody>${body}</tbody>
  `;
}

function escapeAttr(s) {
  return String(s)
    .replaceAll("&", "&amp;")
    .replaceAll('"', "&quot;")
    .replaceAll("<", "&lt;")
    .replaceAll(">", "&gt;");
}

export function renderOutput(store, els) {
  const leafIds = store.leafIds();
  const leafNodes = leafIds.map(id => store.getNode(id));

  if (store.state.outputMode === "json") {
    els.outputHint.textContent = "JSON reflects leaf subnets only (current plan).";
  } else {
    els.outputHint.textContent = "HTML is a static table of leaf subnets only (current plan).";
  }

  // Actual output is set by main.js (to avoid circular imports between render and output modules)
  els.onNeedOutput(leafNodes);
}

import { createStore } from "./state/store.js";
import { renderApp } from "./ui/render.js";
import { toMinimalJson } from "./output/toJson.js";
import { toStaticHtmlTable } from "./output/toHtmlTable.js";

const store = createStore();

const els = {
  baseCidr: document.getElementById("baseCidr"),
  applyBase: document.getElementById("applyBase"),
  reset: document.getElementById("reset"),
  showDetails: document.getElementById("showDetails"),
  outputFormat: document.getElementById("outputFormat"),
  outputFormatLabel: document.getElementById("outputFormatLabel"),
  copyOutput: document.getElementById("copyOutput"),
  error: document.getElementById("error"),
  table: document.getElementById("subnetTable"),
  outputCode: document.getElementById("outputCode"),
  outputHint: document.getElementById("outputHint"),
  onNeedOutput: (leafNodes) => {
    const out = store.state.outputMode === "json"
      ? toMinimalJson(leafNodes)
      : toStaticHtmlTable(leafNodes, { showDetails: store.state.showDetails });

    els.outputCode.textContent = out;
  }
};

function setError(msg) {
  if (!msg) {
    els.error.hidden = true;
    els.error.textContent = "";
  } else {
    els.error.hidden = false;
    els.error.textContent = msg;
  }
}

function syncControlsFromState() {
  els.baseCidr.value = store.state.baseCidr;
  els.showDetails.checked = store.state.showDetails;
  els.outputFormat.checked = store.state.outputMode === "html";
  els.outputFormatLabel.textContent = `Output: ${store.state.outputMode.toUpperCase()}`;
}

els.applyBase.addEventListener("click", () => {
  try {
    setError("");
    store.initWithBase(els.baseCidr.value);
    renderApp(store, els);
  } catch (e) {
    setError(e.message || String(e));
  }
});

els.reset.addEventListener("click", () => {
  setError("");
  store.initWithBase("10.0.0.0/24");
  renderApp(store, els);
  syncControlsFromState();
});

els.showDetails.addEventListener("change", () => {
  store.setShowDetails(els.showDetails.checked);
  renderApp(store, els);
});

els.outputFormat.addEventListener("change", () => {
  store.setOutputMode(els.outputFormat.checked ? "html" : "json");
  syncControlsFromState();
  renderApp(store, els);
});

els.copyOutput.addEventListener("click", async () => {
  try {
    await navigator.clipboard.writeText(els.outputCode.textContent || "");
    // intentionally no toast; keep minimal UI
  } catch (e) {
    setError("Could not copy to clipboard. Your browser may block clipboard access on file:// URLs.");
  }
});

// initial render
syncControlsFromState();
renderApp(store, els);
							</script>
                        </body>
                        </html>
                    